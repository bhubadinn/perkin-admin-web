this is my detailed src files:

/src/constants:
authActions.js:
// Action types for authentication
export const AUTH_ACTIONS = {
  LOGIN_START: 'LOGIN_START',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILURE: 'LOGIN_FAILURE',
  REGISTER_START: 'REGISTER_START',
  REGISTER_SUCCESS: 'REGISTER_SUCCESS',
  REGISTER_FAILURE: 'REGISTER_FAILURE',
  LOGOUT: 'LOGOUT',
  CLEAR_ERROR: 'CLEAR_ERROR',
  INITIALIZE: 'INITIALIZE'
};


/src/contexts:
AuthContext.js:
import {createContext} from "react";

// Create context
const AuthContext = createContext();

export default AuthContext;



AuthContextProvider.jsx:
import React, {useReducer, useEffect} from "react";
import authService from "../services/authService";
import {AUTH_ACTIONS} from "../constants/authActions";
import AuthContext from "./AuthContext";

// Initial state
const initialState = {
  user: null,
  token: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
};

// Reducer
const authReducer = (state, action) => {
  switch (action.type) {
    case AUTH_ACTIONS.LOGIN_START:
    case AUTH_ACTIONS.REGISTER_START:
      return {
        ...state,
        isLoading: true,
        error: null,
      };

    case AUTH_ACTIONS.LOGIN_SUCCESS:
    case AUTH_ACTIONS.REGISTER_SUCCESS:
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        isLoading: false,
        error: null,
      };

    case AUTH_ACTIONS.LOGIN_FAILURE:
    case AUTH_ACTIONS.REGISTER_FAILURE:
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        isLoading: false,
        error: action.payload,
      };

    case AUTH_ACTIONS.LOGOUT:
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        isLoading: false,
        error: null,
      };

    case AUTH_ACTIONS.CLEAR_ERROR:
      return {
        ...state,
        error: null,
      };

    case AUTH_ACTIONS.INITIALIZE:
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: action.payload.isAuthenticated,
        isLoading: false,
      };

    default:
      return state;
  }
};

// Auth provider component
export const AuthProvider = ({children}) => {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Initialize auth state on app start
  useEffect(() => {
    const initializeAuth = () => {
      authService.initializeAuth();
      const user = authService.getCurrentUser();
      const token = authService.getToken();

      if (user && token && authService.verifyToken(token)) {
        dispatch({
          type: AUTH_ACTIONS.INITIALIZE,
          payload: {
            user,
            token,
            isAuthenticated: true,
          },
        });
      } else {
        dispatch({
          type: AUTH_ACTIONS.INITIALIZE,
          payload: {
            user: null,
            token: null,
            isAuthenticated: false,
          },
        });
      }
    };

    initializeAuth();
  }, []);

  // Login function
  const login = async (email, password) => {
    try {
      dispatch({type: AUTH_ACTIONS.LOGIN_START});
      const response = await authService.login(email, password);
      dispatch({
        type: AUTH_ACTIONS.LOGIN_SUCCESS,
        payload: response,
      });
      return response;
    } catch (error) {
      dispatch({
        type: AUTH_ACTIONS.LOGIN_FAILURE,
        payload: error.message,
      });
      throw error;
    }
  };

  // Register function
  const register = async (userData) => {
    try {
      dispatch({type: AUTH_ACTIONS.REGISTER_START});
      const response = await authService.register(userData);
      dispatch({
        type: AUTH_ACTIONS.REGISTER_SUCCESS,
        payload: response,
      });
      return response;
    } catch (error) {
      dispatch({
        type: AUTH_ACTIONS.REGISTER_FAILURE,
        payload: error.message,
      });
      throw error;
    }
  };

  // Logout function
  const logout = async () => {
    try {
      await authService.logout();
      dispatch({type: AUTH_ACTIONS.LOGOUT});
    } catch (error) {
      console.error("Logout error:", error);
      // Still dispatch logout to clear local state
      dispatch({type: AUTH_ACTIONS.LOGOUT});
    }
  };

  // Clear error function
  const clearError = () => {
    dispatch({type: AUTH_ACTIONS.CLEAR_ERROR});
  };

  // Request password reset
  const requestPasswordReset = async (email) => {
    return await authService.requestPasswordReset(email);
  };

  const value = {
    ...state,
    login,
    register,
    logout,
    clearError,
    requestPasswordReset,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Export AuthProvider component only



/src/hooks:
useAuth.js:
import {useContext} from "react";
import AuthContext from "../contexts/AuthContext";

// Custom hook to use auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};




/src/services:
authService.js:
// Mock authentication service that simulates backend communication
// This will be replaced with actual API calls when the backend is ready

const MOCK_USERS = [
  {
    id: 1,
    email: "admin@perkin.com",
    password: "admin123",
    name: "Admin User",
    role: "admin",
    avatar:
      "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face",
  },
  {
    id: 2,
    email: "user@perkin.com",
    password: "user123",
    name: "Regular User",
    role: "user",
    avatar:
      "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face",
  },
];

// Simulate network delay
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

class AuthService {
  constructor() {
    this.currentUser = null;
    this.token = null;
  }

  // Simulate login API call
  async login(email, password) {
    await delay(1000); // Simulate network delay

    const user = MOCK_USERS.find(
      (u) => u.email === email && u.password === password
    );

    if (!user) {
      throw new Error("Invalid email or password");
    }

    // Generate mock JWT token
    const token = this.generateMockToken(user);

    this.currentUser = user;
    this.token = token;

    // Store in localStorage to persist session
    localStorage.setItem("auth_token", token);
    localStorage.setItem("current_user", JSON.stringify(user));

    return {
      user: {...user, password: undefined}, // Remove password from response
      token,
    };
  }

  // Simulate register API call
  async register(userData) {
    await delay(1000); // Simulate network delay

    const {email, password, name} = userData;

    // Check if user already exists
    const existingUser = MOCK_USERS.find((u) => u.email === email);
    if (existingUser) {
      throw new Error("User with this email already exists");
    }

    // Create new user
    const newUser = {
      id: MOCK_USERS.length + 1,
      email,
      password,
      name,
      role: "user",
      avatar:
        "https://images.unsplash.com/photo-1494790108755-2616b612b786?w=150&h=150&fit=crop&crop=face",
    };

    MOCK_USERS.push(newUser);

    const token = this.generateMockToken(newUser);
    this.currentUser = newUser;
    this.token = token;

    // Store in localStorage
    localStorage.setItem("auth_token", token);
    localStorage.setItem("current_user", JSON.stringify(newUser));

    return {
      user: {...newUser, password: undefined},
      token,
    };
  }

  // Simulate logout
  async logout() {
    await delay(500);

    this.currentUser = null;
    this.token = null;

    localStorage.removeItem("auth_token");
    localStorage.removeItem("current_user");
  }

  // Check if user is authenticated
  isAuthenticated() {
    return !!this.token && !!this.currentUser;
  }

  // Get current user
  getCurrentUser() {
    return this.currentUser;
  }

  // Get token
  getToken() {
    return this.token;
  }

  // Initialize auth state from localStorage
  initializeAuth() {
    const token = localStorage.getItem("auth_token");
    const user = localStorage.getItem("current_user");

    if (token && user) {
      this.token = token;
      this.currentUser = JSON.parse(user);
    }
  }

  // Generate mock JWT token
  generateMockToken(user) {
    const header = btoa(JSON.stringify({alg: "HS256", typ: "JWT"}));
    const payload = btoa(
      JSON.stringify({
        sub: user.id,
        email: user.email,
        role: user.role,
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 24 * 60 * 60, // 24 hours
      })
    );
    const signature = btoa("mock-signature");

    return `${header}.${payload}.${signature}`;
  }

  // Verify token (mock implementation)
  verifyToken(token) {
    try {
      const parts = token.split(".");
      if (parts.length !== 3) return false;

      const payload = JSON.parse(atob(parts[1]));
      const now = Math.floor(Date.now() / 1000);

      return payload.exp > now;
    } catch {
      return false;
    }
  }

  // Simulate password reset request
  async requestPasswordReset(email) {
    await delay(1000);

    const user = MOCK_USERS.find((u) => u.email === email);
    if (!user) {
      throw new Error("User not found");
    }

    // In real app, this would send an email
    console.log(`Password reset link sent to ${email}`);
    return {message: "Password reset link sent to your email"};
  }
}

// Create singleton instance
const authService = new AuthService();

export default authService;



/theme:
theme.js:
import {createTheme} from "@mui/material/styles";

// Custom color palette
const colors = {
  black: "#000000",
  lightGreen: "#CFFFE2",
  teal: "#A2D5C6",
  lightGray: "#F6F6F6",
};

const theme = createTheme({
  palette: {
    primary: {
      main: colors.teal,
      light: colors.lightGreen,
      dark: "#7BC4B0",
      contrastText: colors.black,
    },
    secondary: {
      main: colors.black,
      light: "#333333",
      dark: "#000000",
      contrastText: colors.lightGray,
    },
    background: {
      default: colors.lightGray,
      paper: "#FFFFFF",
    },
    text: {
      primary: colors.black,
      secondary: "#666666",
    },
    success: {
      main: colors.teal,
      light: colors.lightGreen,
      dark: "#7BC4B0",
    },
    info: {
      main: colors.teal,
      light: colors.lightGreen,
      dark: "#7BC4B0",
    },
    warning: {
      main: "#FFA726",
      light: "#FFB74D",
      dark: "#F57C00",
    },
    error: {
      main: "#F44336",
      light: "#EF5350",
      dark: "#D32F2F",
    },
  },
  typography: {
    fontFamily: [
      "Inter",
      "-apple-system",
      "BlinkMacSystemFont",
      '"Segoe UI"',
      "Roboto",
      '"Helvetica Neue"',
      "Arial",
      "sans-serif",
    ].join(","),
    h1: {
      fontWeight: 700,
      fontSize: "2.5rem",
      lineHeight: 1.2,
      color: colors.black,
    },
    h2: {
      fontWeight: 700,
      fontSize: "2rem",
      lineHeight: 1.3,
      color: colors.black,
    },
    h3: {
      fontWeight: 600,
      fontSize: "1.75rem",
      lineHeight: 1.4,
      color: colors.black,
    },
    h4: {
      fontWeight: 600,
      fontSize: "1.5rem",
      lineHeight: 1.4,
      color: colors.black,
    },
    h5: {
      fontWeight: 600,
      fontSize: "1.25rem",
      lineHeight: 1.5,
      color: colors.black,
    },
    h6: {
      fontWeight: 600,
      fontSize: "1rem",
      lineHeight: 1.5,
      color: colors.black,
    },
    body1: {
      color: colors.black,
    },
    body2: {
      color: "#666666",
    },
  },
  shape: {
    borderRadius: 12,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: "none",
          fontWeight: 600,
          borderRadius: 8,
          padding: "10px 24px",
          transition: "all 0.3s ease",
        },
        contained: {
          background: `linear-gradient(135deg, ${colors.teal} 0%, ${colors.lightGreen} 100%)`,
          color: colors.black,
          boxShadow: `0 4px 14px 0 ${colors.teal}40`,
          "&:hover": {
            background: `linear-gradient(135deg, #7BC4B0 0%, ${colors.teal} 100%)`,
            boxShadow: `0 6px 20px 0 ${colors.teal}60`,
            transform: "translateY(-2px)",
          },
        },
        outlined: {
          borderColor: colors.teal,
          color: colors.teal,
          "&:hover": {
            borderColor: colors.teal,
            backgroundColor: `${colors.teal}10`,
          },
        },
        text: {
          color: colors.teal,
          "&:hover": {
            backgroundColor: `${colors.teal}10`,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 16,
          boxShadow: `0 4px 6px -1px ${colors.black}10, 0 2px 4px -1px ${colors.black}06`,
          transition: "all 0.3s ease",
          "&:hover": {
            boxShadow: `0 10px 25px -3px ${colors.black}10, 0 4px 6px -2px ${colors.black}05`,
          },
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          "& .MuiOutlinedInput-root": {
            borderRadius: 8,
            transition: "all 0.3s ease",
            "&:hover": {
              "& .MuiOutlinedInput-notchedOutline": {
                borderColor: colors.teal,
              },
            },
            "&.Mui-focused": {
              "& .MuiOutlinedInput-notchedOutline": {
                borderColor: colors.teal,
                borderWidth: 2,
              },
            },
          },
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          fontWeight: 500,
        },
      },
    },
    MuiAvatar: {
      styleOverrides: {
        root: {
          fontWeight: 600,
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          background: `linear-gradient(135deg, ${colors.teal} 0%, ${colors.lightGreen} 100%)`,
          color: colors.black,
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: "none",
        },
      },
    },
  },
});

export default theme;